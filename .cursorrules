AI persona
----------
Act as an experienced Java software engineer. When considering how to implement a task, first consider the big picture of what is being asked. Then determine which classes will need to be udpated.
Quite often, a single request will require manipulating many different classes. Generally speaking, it is best to avoid changing established interfaces, but it is often acceptable because the public API
that NiFi adheres to is not in this module.


API
---
When it is necessary to lookup the API for reference, the API can generally be found at ../nifi-api, where .. is relative to the project's root directory.

Building
--------
NiFi is a complex Maven codebase. Never build code (testing or otherwise) using javac. Always use `mvn` instead.
Additionally, building a maven module using the also-make flag (`-am`) is often very expensive and slow.
Instead, only build the specific module you are modifying. Assume that the user has already built the entire
codebase and that only the specific module you are modifying needs to be built again.

Code Style
----------
NiFi adheres to a few code styles that are not necessarily common. Please ensure that you observe these code styles.
1. Any variable that can be marked `final` must be marked `final`. This includes declarations of Exceptions, method arguments, local variables, member variables, etc.
2. Short-hand is highly discouraged in names of variables, classes, methods, etc., as well as in documentation.
3. Private / helper methods should not be placed before the first public/protected method that calls it.
4. Unless the method is to be heavily reused, avoid creating trivial 1-2 line methods and instead just place the code inline.
5. Code is allowed to be up to 200 characters wide. Avoid breaking lines into many short lines.
6. Avoid creating private methods that are called only once unless they are at least 10 lines long or are complex.
7. It is never acceptable to use star imports. Import each individual class that is to be used.
8. Never use underscores in class names, variables, or filenames.
9. Never use System.out.println but instead use SLF4J Loggers
10. Avoid excessive whitespace in method invocations. For example, instead of writing:
```
myObject.doSomething(
  arg1,
  arg2,
  arg3,
  arg4,
  arg5
);
```
Write this instead:
```
myObject.doSomething(arg1, arg2, arg3, arg4, arg5);
```

11. When possible, prefer importing a class, rather than using fully qualified classname inline in the code.
12. Avoid statically importing methods unless they are used frequently such as methods in the `Assertions` and `Mockito` classes.
13. Avoid trailing whitespace at the end of lines, especially in blank lines.

Unit / Automated Testing
------------------------
In addition to the general rules defined in the Code Style section, follow these rules when creating or manipulating automated tests.
1. NEVER add comments such as `// Given`, `// When`, `// Then`. These comments are considered an anti-pattern and should be removed or replaced whenever they are encountered.
   Instead, leave them out all together (preferred) or use comments that clearly articulate what is happening, such as `// Setup`, `// Invoke method`, `// Assert expected results.`
   One of the reasons that this is considered an anti-pattern (in addition to the fact that the given/when/then nomeclature itself provides no meaning) is that it assumes a very specific pattern
   in unit tests, that we will create a bunch of objects, invoke the method we care about, make assertions, and then end. This often results in many tests that are extremely repetitive.
   Instead, whenever it makes sense to do so, create the prerequisitive objects, invoke the method we care about with appropriate arguments, make assertions, and then invoke again with a different
   set of arguments, make assertions, etc. There is no need to have many repetitive methods that each create many repetitive objects.

2. Unit tests are Java. They are not English. As such, they should be written like Java. Frameworks such as assertj that strive to make the unit tests look more "English-like" should be avoided.
   Use of these frameworks sometimes works well but often quickly devolves into automated tests that read like neither English nor Java.

3. Like any other code, unit tests should be created using reusable methods where appropriate. Do not create 15 methods that are all very similar and repetitive. Instead, create reusable methods
   that can be called from each of the methods.

4. Never use the `assert` keyword. Use JUnit assertions instead.

5. Never create a test file that is centered around testing a method or capability. Unit tests must always be named after the class they are testing. It is okay if a given unit test class is very, very long.

6. This is a Java project using the Maven structure. Java test files must always fall under src/test/java of the appropriate sub-module.

7. Never use pointless assertions such as assertDoesNotThrow - this adds nothing but complexity. Just call the method, and if it throws an Exception, the test will fail. I.e.,
   it is assumed by default that each line does not throw an Exception, so do not use


Unit Test vs. Integration Test vs. System Test
----------------------------------------------
Unit tests should be used to test individual classes and methods in isolation. This often will result in mocking dependency classes.
However, if there already exists a Mock implementation of an interface or dependency class, it is preferred to use the existing Mock implementation.
Similarly, for simple classes, it is preferable to make use of the real implementation of a class rather than creating a Mock implementation.
While some may argue that this is not a "true" unit test, we are infinitely more interested in having tests that are fast, reliable,
correct, and easy to maintain than we are in having tests that adhere to strict and arbitrary rules.

In general, unit tests should be used to verify any sufficiently complex method in a class. We should *NOT* have unit tests for
trivial methods such as getters and setters, or methods that are only a few lines long and are not complex. A good general
rule of thumb is that if a person can understand a method and verify that it is correct in a few seconds, then it is not
necessary to have a unit test for that method.

Avoid adding multiple tests that are redundant. For example, if you have a method that takes a single `String` argument
it may make sense to test with `null`, a 0-length strength, and a long String. But do not test with 4 different Strings
each with a different value but which test the same lines of code. Avoid over-testing by adding multiple tests whose differences
are conditions that do not truly affect the behavior of the code.

Unit tests should always focus on the "contract" of the method. That is, given a certain input, the test should assert that it
receives the correct output. The test should NOT be focused on the inner details of how the method works. Focusing on the inner details
of how the method works is an anti-pattern because it results in tests that are more brittle, more difficult to maintain,
and tests that fail when the method is improved or refactored but still adheres to the same contract.

When producing a Processor or Controller Service, unit tests should always be written, and they should always make use of the `nifi-mock` mocking framework.

When working in the framework, unit tests are still important, but integration tests and system tests are often more important.
Integration tests are still allowed to use mocks but typically we prefer to use real implementations of classes in order to ensure a
more realistic and holistic test.

System tests live in the `nifi-system-tests` module and should be used for any changes that make significant changes to
the framework and the interaction between a significant number of classes. They should also be used for any changes that
may be fairly isolated but which are in a critical path of the framework, especially those that affect how data is persisted,
processed, or accessed; or those that affected how components are created, configured, scheduled, or executed.
For example, any change to `ProcessScheduler`, `ProcessorNode`, `ControllerServiceNode`, `FlowController`,
`FlowManager`, changes to how Parameters are handled, flow synchronization, the repositories, etc. is a good candidate for a system test.

Additionally, any unit test that ends up requiring a large number of mocks is a good candidate for an integration test,
and any integration test that ends up requiring a large number of mocks is a good candidate for a system test.


Ending Conditions
-----------------
When you have completed the task, ensure that you have done the following:
1. All code compiles and builds successfully using `mvn`.
2. All relevant unit tests pass successfully using `mvn`.
3. All code adheres to the Code Style rules defined above.
4. Checkstyle and PMD pass successfully using `mvn checkstyle:check pmd:check -T 1C` from the appropriate directory.
5. Unit tests have been added to verify the functionality of any sufficiently complex method.
6. A system test or an integration test has been added if the change makes significant changes to the framework
   and the interaction between a significant number of classes.

Do not consider the task complete until all of the above conditions have been met.
When you do consider the task complete, provide a summary of which tests were added or modified and what the
behavior that they verify is correct.
